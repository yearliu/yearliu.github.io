---
title: 内存占用优化篇
---
本篇会介绍一些内存问题的产生原理，以及我使用的解决方案

## 基本概念
由于编码的体积增大，或者系统复杂功能过多以及运行时间过长，前端对于内存的消耗会逐步增加，有部分内存是合理增加范围，但是有的却是不应该出现的内存消耗
后者出现的消耗过多后，有可能就会导致整个系统的卡顿\/卡死\/崩溃现象，本篇我们就来讨论一下如何发现这个问题以及一些解决方案

### 内存溢出 
顾名思义溢出，溢出的含义是容器承载不下内容，导致内容跑到了容器外侧，这就是溢出；
内存溢出也是一样，用户分配给了超出内存容器范围的数据量，导致空间无法存储那么大的数据量产生数据丢失或者程序崩溃，这就是内存溢出（OutOf Memory）

### 内存泄露
泄露的概念跟溢出不同，溢出是由于分配的量过多，导致溢出，而泄露更像是一个结果
内存泄露是由于系统中分配出去的内存过多，并且由于各种原因无法进行释放导致内存占用过多，导致整体程序响应不及时，以至于产生系统运行过慢或者系统崩溃的结果，称之为内存泄漏(Memory Leak)

## 如何发现
> 常见现象
+ 页面卡顿
+ 页面产生崩溃问题
+ 页面响应变慢
+ 内存占用过高

> 如果页面运行中产生或者已有以上现象，并且放置后没有任何的缓解，那就必须要当心系统是否产生了内存方面问题了
常见的内存问题有：

并不是所有内存溢出的结果都会导致内存泄露，但是大量积累的溢出大概率导致泄露的发生

### 排查手段
#### 系统控制台
windows可用 控制台监控系统资源消耗来确定是否存在对应问题:
1. 打开任务管理器
> Ctrl + Alt + Delete
2. 找到浏览器进程 
> 建议使用Chrome ， Chrome 对于自身的内存管理回收机制存在缺陷，更便于用于内存问题排查
3. 系统运行过程中监控内存栏目的变化
> 系统正常运行中会产生内存使用的波动，该过程中浏览器最好保持只打开了目标系统页面
系统使用过程中，会有一些或大或小的正常内存波动，我们在排查内存问题时要注意区分正常波动以及消耗
+ 运行过程中，当用户进行操作时，会产生内存上的增量，这是个正常的过程，增量按照复杂度可能会瞬间有上百的跳跃，这时候我们应该静候操作结束，一般会在20s内系统对相关内存进行释放，这时候可以看到一个峰值的产生
+ 进入新页面时，由于页面资源加载，页面必然会产生一个峰值的消耗，并且结束后的内存平均占用可能会高于进入页面前的，这也是系统必要开销，在合理范围内可以进行忽略，不属于排查点
+ 整体系统进入一个内存使用量的平均值上限，在此基础上没有继续进行一个梯度的增加或者总观没有一个坡度上的增加态势；则系统趋于平稳，该情况下可能系统内存在一定的内存释放问题，但是不属于内存溢出，较小概率存在内存泄露的风险，可以选择性排查

#### chrome开发者工具-录制
推荐使用Chrome工具进行排查，原因不进行复述
1. F12 打开开发者工具
2. 顶部栏目切换到 Performance (性能) 
3. 勾选选中 Memory 
4. 开始录制操作过程 
5. 结合操作流程分析内存消耗曲线
> 注意事项与系统控制台一致，调试过程中可以相互参照

#### chrome开发者工具-内存分析
1. F12 打开开发者工具
2. 顶部栏目切换到 Memory (内存) 
3. 勾选选中 Memory 
4. 选中想使用的模式，点击左上角录制按钮
5. 等待输出内存使用情况，加以分析
> 建议在使用前后各拍一个快照进行对照分析，或者用时间轴方式录制，分析各时间段内存使用情况
> 注意事项与系统控制台一致，调试过程中可以相互参照

## 问题与处理
>以下为我以往工作中，遇到过的内存问题的可能成因，发出来仅供参考，如果各位有更多的解决思路欢迎发邮箱进行讨论

### 1. import 与 require 
检查系统内的require使用情况，非必要替换为import
他们的相似点：
>1. 用于导入其他模块内容
2. 编译后语法相同

差异点：
>1. require无法按模块加载，只能整个引入 / import 可单独引入某个模块
2. require在执行过程中加载 / import 在编译时执行加载
3. import必须放在文件头部，require可放在代码中央
4. require会阻塞代码执行，按序加载 / import 为异步
5. require可动态加载 / import 只能加载固定文件名
6. <span style="color:red">*</span> require 加载方式是拷贝，会产生新的存储空间消耗 / import更像是引用，不会产生新的储存空间

require多次调用，会产生多个无法释放的存储空间消耗，在优化中应该特别注意这一点
总体来说代码中使用import的各方面性能都优于require ，除非项目有特别需求或者需要动态加载，否则一律使用import代替
> 解决方案 ：
    找到代码中的require，代替为import
### 2. keep-alive 问题检查
检查是否有keep-alive属性的组件，如果有则进行相关分析，是否需要保持后台占用
> 解决方案 ：
    减少keep-alive组件的使用，必须使用时进行组件优化
### 3. 全局变量检查
全局变量/常量 系统不会进行释放，所产生的系统占用会再系统内永久占用 注意检查指向window的变量/常量；
如何辨别全局变量的方法不做赘述，如有疑问欢迎讨论
> 解决方法 ： 

### 4. 检查事件注册 addEventListener 
addEventListerner 中存储的是个待执行栈，不会对事件主动进行任何形式的销毁，需要使用者进行主动的removeEventListener 
> 解决方案：
    1. 所有传入的事件需要进行定义后传入，绝不允许传入匿名方法
    2. addEventListener 与 removeEventListener 一一对应 ；如果会进行重复addEventListener ，先进行一次remove
    3. 使用addEventListener 前先设计销毁方案，优先完成销毁方案再进行使用
### 5. 检查js中对于DOM引用
如果js中有对于DOM节点的使用，则在js变量释放前DOM节点即使被删除，也不会进行内存释放
> 解决方法： 
    不要给全局变量复制DOM相关内容，考虑在闭包内声明，让变量随着闭包销毁
### 6. 定时器检查 
定时器进行赋值使用，检查系统内有无未清理定时器
> 解决方案： 
    在新建定时器前，先使用clearInterval / clearTimeout 方法对定时器进行清理，防止无源定时器出现，无源定时器一旦出现则无法清理
### 3. 闭包排查
该点为代码质量问题，请自行保证代码质量不出现闭包无法销毁导致的内存泄漏，该处不做过多赘述

## 尾记
以上内容为我在工作中解决过的一些性能优化问题，前端弱语言特性以及前端从业所关注的方向导致前端开发人员在一开始会比较少关注性能相关的问题
但是工作一段时间后，或者从事前端架构设计和框架开发后，会发现性能优化也是前端的重中之重，借此也希望各位在设计期间多关注与代码质量，做好基础能力上的设计
否则在后期可能会因为性能问题而造成项目的巨大瓶颈
致此
祝各位·码运昌隆